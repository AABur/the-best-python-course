1
00:00:00,571 --> 00:00:05,738
Всем привет, меня зовут Никита Соболев, и это
лучший курс по Python. Сегодня у нас необычное

2
00:00:05,758 --> 00:00:12,206
видео, можно сказать, особенное и уникальное, потому что наш
гость сегодня особенный и уникальный. Сегодня я буду говорить

3
00:00:12,306 --> 00:00:19,876
с другим разработчиком ядра Python, который знает много
о том, как работают свободные потоки, JIT, а также многие другие

4
00:00:19,896 --> 00:00:25,824
внутренние части Python. Он также является членом
Steering Council. Это такой специальный управляющий

5
00:00:25,844 --> 00:00:32,862
орган для всего Python. И, конечно, я специально
подготовил для вас русские субтитры. Вы можете включить их

6
00:00:32,882 --> 00:00:37,795
прямо на YouTube и слушать на английском, а читать на
русском, если вам так удобнее. Также есть

7
00:00:38,517 --> 00:00:46,536
английские субтитры, так что вы можете использовать их, если хотите. Я
очень хочу, чтобы все разработчики Python понимали, как

8
00:00:46,556 --> 00:00:51,546
управляется такой большой проект, как самый
популярный язык программирования в мире. Потому что

9
00:00:51,566 --> 00:00:58,439
это тоже настоящая инженерная задача. Конечно, не
каждый из нас столкнется с этим в реальной жизни.

10
00:00:58,459 --> 00:01:03,147
Однако ничто не мешает нам посмотреть, как это
действительно работает, и привнести что-то новое и

11
00:01:03,468 --> 00:01:08,096
интересное в нашу жизнь. Многие до сих пор
ошибочно полагают, что Гвидо ван Россум принимает все

12
00:01:08,116 --> 00:01:13,264
решения самостоятельно. Однако это не так.
Сейчас Python управляется Steering Council. Это

13
00:01:13,284 --> 00:01:19,955
избранный комитет из пяти человек, который меняется
каждый год. Любой разработчик ядра может войти в него, даже

14
00:01:19,975 --> 00:01:27,066
не разработчики ядра. Именно Steering Council
решает, какие PEP будут приняты, а какие PEP

15
00:01:27,086 --> 00:01:32,515
будут отклонены. То есть буквально пять
человек определяют судьбу всего Python. Сегодня я

16
00:01:32,595 --> 00:01:39,202
пригласил одного из них, чтобы поговорить обо всем этом процессе.
И, конечно, когда такой человек приходит к вам в гости,

17
00:01:39,382 --> 00:01:44,988
вы не можете не спросить его о других интересных
темах. Например, Донгхи На — один из основных

18
00:01:45,008 --> 00:01:50,314
участников проекта свободных потоков. Мы также
немного затронем вопрос JIT, потому что сейчас

19
00:01:50,334 --> 00:01:56,521
рассматривается PEP, который изменит работу JIT,
и это очень интересно обсудить. Ну,

20
00:01:56,541 --> 00:02:03,775
мы также затронем такие две темы, как Relocatable
Builds и BOLT. Для тех, кто не знает, что это такое, конечно,

21
00:02:03,855 --> 00:02:08,804
мы расскажем все во время интервью. Ну а теперь перейдем
к самому интервью. Давайте начнем. Донгхи На, очень

22
00:02:08,884 --> 00:02:16,878
приятно видеть вас здесь. Вы очень, очень
талантливый разработчик и член Steering Council. И

23
00:02:16,918 --> 00:02:22,646
сегодня мы поговорим о вашем вкладе в Python,
вашей работе в Steering Council и многом

24
00:02:22,686 --> 00:02:29,334
другом, связанном с CPython. Спасибо большое за то, что присоединились,
и, пожалуйста, представьтесь. ОК, привет. Меня зовут

25
00:02:29,354 --> 00:02:40,446
Донгхи, я из Южной Кореи. Я начал вносить вклад в CPython
с 2017 года, а в 2020 году стал разработчиком ядра

26
00:02:41,127 --> 00:02:48,274
CPython. Сейчас я работаю членом Steering Council
с этого года. В последнее время я сосредоточен на том, как

27
00:02:48,395 --> 00:02:58,36
работают свободные потоки и другие аспекты CPython. Мне
очень нравится вносить вклад в open source, да. Это действительно

28
00:02:58,4 --> 00:03:05,527
здорово, потому что вы были первым, кто познакомил
меня с командой Python Triage в 2021 или 2022 году,

29
00:03:05,587 --> 00:03:14,745
где-то так. И я до сих пор благодарен за это.
Спасибо. Было очень весело работать триажером

30
00:03:14,765 --> 00:03:22,718
и изучать все рабочие процессы Python и его внутренности.
Не могли бы вы объяснить моей аудитории, что такое

31
00:03:23,159 --> 00:03:29,805
Steering Council? Да, Python Steering Council — это
небольшая группа разработчиков ядра Python,

32
00:03:29,845 --> 00:03:36,411
которые избираются для наблюдения за разработкой и
направлением развития языка Python. С 2018 года,

33
00:03:36,491 --> 00:03:45,079
после того как Гвидо ушел с позиции BDFL, был
сформирован первый Steering Council, и

34
00:03:45,219 --> 00:03:54,804
Гвидо был одним из его членов в первый год.
Основная ответственность

35
00:03:54,824 --> 00:04:01,975
Steering Council заключается в управлении процессом PEP и
принятии решений о том, какие PEP будут приняты. И

36
00:04:01,995 --> 00:04:09,711
мы также управляем событиями для разработчиков ядра, включая
Python Language Summit и спринты разработчиков ядра,

37
00:04:09,771 --> 00:04:17,78
и так далее. Многое на самом деле
управляется людьми из Steering Council. Так что

38
00:04:17,8 --> 00:04:26,409
в основном Steering Council — это группа людей из Python,
которая направляет и контролирует всю эволюцию

39
00:04:26,489 --> 00:04:35,019
языка Python. Это большая работа. И
это самые талантливые и самые

40
00:04:35,039 --> 00:04:42,327
знающие инженеры в команде разработчиков ядра Python.
Я думаю, что многие люди должны ценить их

41
00:04:42,808 --> 00:04:49,478
работу, потому что действительно очень сложно двигать
такой проект. Не могли бы вы рассказать, в чем

42
00:04:49,538 --> 00:04:56,81
заключается ежедневная работа члена Steering Council? Что вы делаете
ежедневно? Каковы ваши обязанности? Да,

43
00:04:56,91 --> 00:05:05,056
первое большое изменение с тех пор, как я начал работать
в Steering Council,

44
00:05:05,096 --> 00:05:11,85
честно говоря, это то, что я не читал столько PEP,
сколько читаю сейчас. Но после того, как я

45
00:05:11,87 --> 00:05:23,024
был избран членом Steering Council, я, конечно же,
читаю все PEP, знаете, три PEP в неделю,

46
00:05:23,145 --> 00:05:30,025
и мы обсуждаем каждую группу PEP на еженедельных
встречах.

47
00:05:30,045 --> 00:05:41,738
В моем часовом поясе это около 5 утра, в районе 6 утра в пятницу, и мы
обсуждаем группу PEP, которые находятся в списке

48
00:05:41,859 --> 00:05:52,894
на сегодня. Затем мы обсуждаем каждый PEP,
почему его следует принять, или

49
00:05:53,235 --> 00:06:01,602
почему его следует отклонить, или почему его следует
обновить, чтобы он стал более убедительным для членов SC.

50
00:06:01,883 --> 00:06:09,472
Это наша обычная задача. Кроме того, мы занимаемся
другими вещами, например,

51
00:06:09,492 --> 00:06:17,942
как вы знаете, когда вас повышают до разработчика ядра Python,
вы можете получить грант на поездку на PyCon в США,

52
00:06:18,383 --> 00:06:25,552
и мы должны решить, кому выдать грант.
Мы обсуждаем это с членами

53
00:06:26,513 --> 00:06:34,003
PSF. И такие задачи решаются на каждой
еженедельной встрече. Допустим, я хочу написать PEP.

54
00:06:34,063 --> 00:06:45,177
С чего мне начать? Если вы разработчик ядра, вы
можете просто написать PEP. И вы можете поделиться черновиком

55
00:06:45,197 --> 00:06:55,234
PEP на discuss.python.org. Затем люди
будут комментировать его. И, наконец,

56
00:06:55,254 --> 00:07:03,723
члены Steering Council могут рассмотреть ваш PEP. Но если
вы не разработчик ядра, вам, возможно, нужно найти

57
00:07:03,944 --> 00:07:11,452
человека, который спонсирует ваш PEP. Это основное
различие между автором, являющимся разработчиком ядра, и

58
00:07:11,512 --> 00:07:19,582
не являющимся им. Допустим, я нашел кого-то из команды ядра,
кто хочет спонсировать этот PEP, который я написал. Что я должен

59
00:07:19,682 --> 00:07:28,092
включить в этот PEP, чтобы его приняли? Какие разделы,
примеры и тому подобное?

60
00:07:28,172 --> 00:07:36,643
Да, есть много PEP, которые мы
принимаем. Есть разные виды PEP.

61
00:07:36,683 --> 00:07:45,582
Иногда это технические вещи, а иногда
это управленческие вещи. Так что это зависит от того, что вы

62
00:07:45,642 --> 00:07:51,739
хотите написать. Если вы хотите написать технический PEP,
вам нужно объяснить, зачем этот PEP нужен и какую

63
00:07:51,779 --> 00:08:01,536
преимущество он даст пользователям Python, и как
мы не сломаем многое. Это

64
00:08:01,576 --> 00:08:09,791
очень важно для разработчиков Python, потому что мы
управляем очень, очень большой кодовой базой, одной из самых больших в

65
00:08:09,851 --> 00:08:17,496
мире. Поэтому мы очень осторожны в вопросах
совместимости. И также вы должны

66
00:08:17,857 --> 00:08:23,964
убедить, как это будет эффективно, как это повлияет
на множество кодовых баз, знаете, множество

67
00:08:25,085 --> 00:08:35,678
статических вещей. Такого рода информация должна быть
включена в ваш PEP. Это не сильно отличается от технической

68
00:08:35,798 --> 00:08:43,491
документации, которую вы пишете в любой компании. Так что
если вы работаете в любой технологической компании,

69
00:08:43,731 --> 00:08:49,296
вы, вероятно, пишете техническую документацию там,
то же самое будет и для PEP.

70
00:08:49,316 --> 00:08:56,743
Хорошо. Есть ли у вас личные цели как у члена
Steering Council? Например, есть ли у вас какие-то

71
00:08:56,783 --> 00:09:04,089
большие изменения, которые вы хотите достичь в технической
части CPython или что-то в этом роде? О, да,

72
00:09:04,61 --> 00:09:11,338
есть две вещи. Первая — это техническая
цель, а вторая — нетехническая.

73
00:09:11,358 --> 00:09:16,806
Говоря о технической части, как вы знаете,
я очень заинтересован в работе над свободными потоками. Так что я

74
00:09:16,826 --> 00:09:28,464
стараюсь поддержать успешное завершение проекта
свободных потоков. И если что-то

75
00:09:28,824 --> 00:09:37,717
нуждается в дополнительной поддержке, я постараюсь поддержать. И
другая вещь — это проект Faster CPython.

76
00:09:37,777 --> 00:09:44,445
Есть много экспериментов, включая JIT или
интерпретатор Tier 2. Есть общие области для

77
00:09:44,766 --> 00:09:53,136
свободных потоков и Faster CPython.
И сотрудничество между ними очень, очень

78
00:09:53,176 --> 00:10:00,945
важно. Так что я стараюсь поддерживать их тоже. Также в последнее время
многие люди говорят о

79
00:10:01,426 --> 00:10:21,294
ARM CPU, потому что, в отличие от x86, ARM CPU
очень энергоэффективен, и это влияет

80
00:10:21,314 --> 00:10:30,568
на цены в облаке, поэтому люди очень заинтересованы
в использовании ARM чипов. Но нам нужно больше усилий

81
00:10:30,608 --> 00:10:41,004
для более оптимизированного CPython на ARM. Так что я стараюсь
поддерживать всех, кто работает над этим. Это мои основные

82
00:10:41,024 --> 00:10:49,077
технические интересы. Во-вторых, как вы знаете,
многие разработчики ядра находятся в Северной

83
00:10:49,117 --> 00:10:57,365
Америке и в Европе, в основном в Западной Европе. В
регионе APAC, например, в Азии, Токио, Корее,

84
00:10:57,405 --> 00:11:04,295
Сингапуре или Китае, очень мало разработчиков ядра.
Так что я стараюсь

85
00:10:57,405 --> 00:11:04,295
Сингапур или Китай, здесь очень мало разработчиков ядра.
Так что я стараюсь

86
00:11:04,415 --> 00:11:14,489
представлять наши технологические компании,
когда они работают над CPython, и стараюсь

87
00:11:15,049 --> 00:11:22,35
представлять их потребности. А также я стараюсь организовывать
локальные спринты, чтобы люди могли

88
00:11:22,43 --> 00:11:30,877
участвовать, даже если в регионе APAC очень мало разработчиков ядра.
Так что это две мои основные цели как члена

89
00:11:31,358 --> 00:11:39,231
Steering Council в этом году. Да, благородные
цели. Я думаю, что мы все должны поддерживать ваши усилия в

90
00:11:39,251 --> 00:11:47,832
этой области, потому что я считаю, что свободные потоки — это большая
функция, и она должна стать следующим этапом развития Python

91
00:11:47,872 --> 00:11:53,222
и следующим большим шагом для самого языка. Да, действительно ценю это. У нас есть

92
00:11:53,262 --> 00:12:02,474
еще один вопрос о вашей работе в Steering Council. Я думаю, что вы
просматриваете много интересных PEP, и, возможно, вы можете назвать

93
00:12:02,514 --> 00:12:10,164
несколько из них, самых интересных для вас или самых технически
сложных, например, ваши топ-3 PEP, которые сейчас в работе.

94
00:12:11,265 --> 00:12:19,536
Хорошо, я не могу выбрать три PEP в данный момент. Их очень много,
но я могу выбрать

95
00:12:19,556 --> 00:12:27,509
один. Один из лучших PEP для меня, возможно, в этом году, это
PEP 765, написанный Ирит Катриэль. Он о

96
00:12:27,629 --> 00:12:39,387
запрете return/break/continue в блоке finally.
Этот PEP очень хорошо написан,

97
00:12:39,607 --> 00:12:47,271
потому что он очень хорошо исследован. Например:
сколько людей используют неправильный

98
00:12:47,291 --> 00:12:57,501
код на Python. И затем он предлагает
способ, как исправить код людей

99
00:12:57,561 --> 00:13:05,47
естественным образом, ничего не ломая. Так что
для меня это лучший PEP этого года, потому что он

100
00:13:05,51 --> 00:13:15,975
очень убедителен, а также предоставляет статистику
и предлагает способ писать

101
00:13:16,015 --> 00:13:25,437
лучший код. Так что и технические, и нетехнические
аспекты великолепны. Я многое узнал из этого PEP, так что

102
00:13:25,478 --> 00:13:34,727
для меня это лучший PEP, который я читал до этого
февраля. Возможно, после февраля у нас будет больше отличных PEP.

103
00:13:34,767 --> 00:13:43,59
Но для меня, на данный момент, это лучший PEP. Я
согласен. Это действительно отличный PEP. И я думаю, что

104
00:13:43,63 --> 00:13:50,985
это была одна из самых проблемных частей синтаксиса Python.
И я думаю, что много реального кода имело

105
00:13:51,045 --> 00:14:03,079
эту ошибку. И здорово, что теперь у нас есть способы исправить это
в более широком смысле. Хорошо, мы также хотим поговорить о вашей

106
00:14:03,099 --> 00:14:12,727
работе над свободными потоками, потому что Steering Council — это
что-то, к чему прикасаются очень немногие, но свободные потоки —

107
00:14:12,807 --> 00:14:22,015
это что-то для всех. Не могли бы вы объяснить, что такое
свободные потоки, очень кратко, для людей,

108
00:14:22,295 --> 00:14:30,882
которые еще не знакомы с этим, потому что 3.13 вышел не так давно,
и эта функция все еще отключена по умолчанию.

109
00:14:30,942 --> 00:14:40,05
Да, я очень рад, что вы не используете термин "без GIL".

110
00:14:40,07 --> 00:14:48,4
В основном, свободные потоки — это проект, который пытается
убрать GIL. И, честно говоря, он находится на

111
00:14:48,821 --> 00:14:57,611
экспериментальной стадии в CPython на данный момент. И
мы используем официальный термин "свободные потоки"

112
00:14:57,771 --> 00:15:05,86
вместо "без GIL". Так что если вы используете "без GIL",
то вам стоит изменить термин. Было много

113
00:15:05,98 --> 00:15:14,499
попыток убрать GIL с первых лет CPython.
И многие пытались, и многие

114
00:15:14,579 --> 00:15:21,348
потерпели неудачу. Но несколько лет назад, я не помню
точно, в каком году, Сэм Гросс, который работает в

115
00:15:21,368 --> 00:15:30,16
Facebook* (в России признана экстремистской и запрещена) AI Research,
отправил письмо, что ему удалось убрать GIL. И я думаю, что

116
00:15:30,48 --> 00:15:37,93
никто не поверил, что проект был успешным в тот момент.
Несколько человек сказали: пожалуйста, покажите ваши

117
00:15:38,062 --> 00:15:45,714
бенчмарки. И затем Сэм показал успешные
бенчмарки из раннего релиза, и все были

118
00:15:45,794 --> 00:15:52,945
удивлены. И вот мы здесь, два года спустя.
Но нам все еще нужно время для анализа.

119
00:15:53,006 --> 00:15:59,998
В свободных потоках много компонентов,
таких как использование mimalloc и

120
00:16:00,158 --> 00:16:05,127
нового подсчета ссылок. И это заняло больше
двух лет, от Python 3.13 до этого момента.

121
00:16:05,168 --> 00:16:13,896
Многие люди участвуют в проекте
свободных потоков. И большинство из них

122
00:16:14,157 --> 00:16:22,358
из Meta* (в России признана экстремистской и запрещена),
потому что Meta* финансирует проект и до сих пор поддерживает его.

123
00:16:22,498 --> 00:16:28,774
На раннем этапе мне пришлось настроить начальный CI
с использованием GitHub Actions для сборки CPython с поддержкой свободных потоков.

124
00:16:30,003 --> 00:16:38,073
Это очень техническая, но базовая вещь, потому что нам
нужно убедиться, что CPython с поддержкой свободных потоков

125
00:16:38,233 --> 00:16:44,02
работает хорошо. И затем, другая вещь, на которой я сосредоточился, — это
сделать среду выполнения Python совместимой с проектом свободных потоков, потому что

126
00:16:44,04 --> 00:16:52,95
одна из самых больших технических проблем, с которыми мы сталкиваемся
в CPython с поддержкой свободных потоков, — это то, что мы не хотим

127
00:16:53,11 --> 00:16:59,919
создавать много фрагментации между обычной
сборкой и сборкой с поддержкой свободных потоков. Потому что, если

128
00:16:59,979 --> 00:17:07,511
вы убираете GIL, все внезапно становится
не потокобезопасным. Так что в среде выполнения Python нам нужно заботиться

129
00:17:07,912 --> 00:17:15,565
о данных и потокобезопасности. Но, знаете, есть блокировки, критические секции
и атомарные операции. Вы упомянули два очень важных

130
00:17:15,625 --> 00:17:24,48
термина: атомарные операции и критические секции. Не могли бы вы объяснить,
что это такое, для более широкой аудитории?

131
00:17:24,861 --> 00:17:32,038
Хорошо, критические секции — это секции, которые
гарантируют потокобезопасность

132
00:17:32,439 --> 00:17:40,138
без использования явной блокировки. Упрощенно,
только один поток может находиться в этой

133
00:17:40,237 --> 00:17:49,693
секции, так что все будет потокобезопасно в этой
секции по определению, но недостаток, очевидно, в стоимости.

134
00:17:49,713 --> 00:17:59,329
Недостаток критических секций в том, что может
произойти замедление производительности, потому что другие

135
00:17:59,369 --> 00:18:07,043
потоки не могут находиться в этой секции и должны ждать. Но да,
иногда нам нужна эта функция. А атомарные операции — это не

136
00:18:07,083 --> 00:18:13,949
критические секции, они представляют собой низкоуровневые
операции, которые могут быть выполнены атомарно. Так что даже если

137
00:18:13,989 --> 00:18:23,137
несколько потоков пытаются изменить одно атомарное целое число,
гарантируется, что не будет гонки, и оно будет изменено

138
00:18:23,197 --> 00:18:32,125
по одному. Но это не гарантирует правильной
транзакции внутри объектов Python. Так что

139
00:18:32,145 --> 00:18:40,032
случаи использования могут быть разными между критическими
секциями и атомарными операциями. Заметьте, что

140
00:18:40,534 --> 00:18:49,394
все это происходит в кодовой базе на C. Так что если вы
просто пользователь Python, вам не нужно об этом заботиться, но если

141
00:18:49,594 --> 00:18:56,945
вы поддерживаете C-расширения, то, возможно, вам
нужно об этом позаботиться. Да. Вам точно нужно

142
00:18:57,085 --> 00:19:01,821
об этом заботиться, потому что в будущем вам точно
понадобится поддержка свободных потоков. И в основном вы

143
00:19:01,921 --> 00:19:09,284
можете сказать так: атомарные операции — это примитив, поддерживаемый
компилятором. Критические секции — это наша собственная концепция,

144
00:19:09,344 --> 00:19:16,152
которую CPython поддерживает и развивает как функцию.
А что насчет C-расширений? Нужно ли авторам C-расширений

145
00:19:16,172 --> 00:19:23,86
поддерживать свободные потоки в ближайшее время? Да,
определенно. Возможно, некоторым из них не нужно

146
00:19:23,88 --> 00:19:31,148
ничего менять, но я думаю, что, когда вы думаете о том,
почему люди пишут C-расширения, это в основном

147
00:19:31,268 --> 00:19:38,296
из-за проблем с производительностью. Так что, возможно,
это просто чистый код на C, который не связан с объектами Python.

148
00:19:38,356 --> 00:19:47,066
Так что в этом случае вам не нужно заботиться о Python API.
Но если вы работаете с Python C-API,

149
00:19:47,086 --> 00:19:55,997
то вам нужно заботиться о новых условиях гонки.
Даже если вы используете C-API, который предоставляет заимствованные ссылки,

150
00:19:56,057 --> 00:20:05,795
то это не гарантирует потокобезопасность. Так что вам нужно
перейти на использование явного API подсчета ссылок. И если вы заботитесь об этом,

151
00:20:05,835 --> 00:20:13,209
то, если вы поищете в документации, мы уже
предоставили всю информацию об этом. Так что вы можете прочитать и

152
00:20:13,249 --> 00:20:22,559
переключиться на это. И если вам нужно что-то еще, например, больше API,
то вы можете просто создать issue в репозитории CPython,

153
00:20:22,599 --> 00:20:30,427
и люди отреагируют на ваши потребности. Я думаю, что
подсчет ссылок изменился довольно сильно в сборке

154
00:20:30,547 --> 00:20:36,393
с поддержкой свободных потоков. Не могли бы вы уточнить, как и
что изменилось в этом? Да, это очень техническая

155
00:20:36,413 --> 00:20:44,642
тема. Я не уверен, что смогу объяснить это очень просто.
Хорошо. По умолчанию, с GIL,

156
00:20:44,722 --> 00:20:52,951
есть только один счетчик ссылок. Именно поэтому нам нужен был GIL
до сборки с поддержкой свободных потоков, потому что с несколькими потоками,

157
00:20:53,052 --> 00:21:03,271
если все они попытаются изменить счетчик ссылок,
возникнет состояние гонки. Нам нужна блокировка.

158
00:21:03,331 --> 00:21:11,326
В обычных сборках эта блокировка — это GIL в стандартной сборке.
Но в сборке с поддержкой свободных потоков есть

159
00:21:11,366 --> 00:21:21,325
два счетчика ссылок. Один — это общий счетчик ссылок,
а другой — извините, я не могу вспомнить его название.

160
00:21:21,345 --> 00:21:30,323
Но это счетчик ссылок для потока-владельца. Если поток владеет этим объектом,

161
00:21:30,443 --> 00:21:37,032
он может изменять этот счетчик ссылок самостоятельно,
без атомарных операций или блокировок. Так что это будет

162
00:21:37,072 --> 00:21:46,527
очень быстро. А если другой поток разделяет тот же объект,
он изменяет общий счетчик ссылок.

163
00:21:46,768 --> 00:21:57,685
И он будет изменен с помощью атомарной операции, а затем
будет объединен внутренним процессом. Так что это гарантирует

164
00:21:58,12 --> 00:22:08,839
потокобезопасность общего значения счетчика ссылок. Основная гипотеза
этого подхода заключается в том, что большинство объектов Python

165
00:22:08,879 --> 00:22:18,296
очень быстро. И если другой поток использует тот же объект,
они фактически изменяют общий счетчик ссылок.

166
00:22:18,616 --> 00:22:28,132
И он будет изменен с помощью атомарной операции, а затем
будет объединен внутренним процессом. Таким образом, это

167
00:22:28,192 --> 00:22:37,307
гарантирует потокобезопасность общего
значения счетчика ссылок. Основное предположение этого

168
00:22:37,844 --> 00:22:45,372
подхода заключается в том, что большинство объектов Python
фактически принадлежат одному потоку. В большинстве случаев мы

169
00:22:45,392 --> 00:22:54,101
не заботимся об общем счетчике ссылок, но в некоторых
случаях, когда они должны быть разделены с другим потоком,

170
00:22:54,241 --> 00:23:00,027
тогда они изменяют общий счетчик ссылок, и
это приведет к небольшому замедлению, но мы можем

171
00:23:00,127 --> 00:23:12,648
преодолеть это. И если какой-то объект, например, CodeObject,
может быть доступен

172
00:23:12,668 --> 00:23:19,081
нескольким потокам. В этом случае мы фактически используем
отложенный счетчик ссылок. И эта техника означает, что

173
00:23:21,005 --> 00:23:31,469
мы откладываем подсчет ссылок до некоторого момента в будущем. Таким образом,
мы видим, что мы успешно преодолели несколько проблем,

174
00:23:31,99 --> 00:23:38,558
которые возникли, когда мы удалили GIL, как вы можете видеть, есть
несколько техник для этого. Это то, что

175
00:23:38,678 --> 00:23:43,805
произошло в проекте free-threading. Я не уверен,
что это самое простое объяснение, но это моя лучшая

176
00:23:44,245 --> 00:23:51,254
попытка. Да. Я думаю, ты отлично справился. Я действительно
ценю твое объяснение. Спасибо. Я также думаю,

177
00:23:51,294 --> 00:23:57,944
что мы должны упомянуть, как будет работать новый GC, потому что если
мы затронули счетчики ссылок, я думаю, это справедливо

178
00:23:58,004 --> 00:24:04,553
затронуть и GC. Можешь ли ты поделиться своими мыслями
о будущем GC и работе, которая была проделана

179
00:24:04,614 --> 00:24:13,947
над ним? Да, я не эксперт в GC, поэтому я не могу
объяснить глубокие вещи в этом разговоре. Да, я

180
00:24:13,967 --> 00:24:21,699
тоже. Я понятия не имею, как это работает внутри. Это слишком
сложно. Да, но две вещи, возможно. Мы ввели

181
00:24:21,739 --> 00:24:29,193
концепцию "Stop the World". Ее не было в стандартной сборке.
Она будет включена в сборку free-threading.

182
00:24:29,254 --> 00:24:35,865
И это тот же механизм, который используется, если вы используете Java или
несколько других языков, потому что нам нужно остановить

183
00:24:35,925 --> 00:24:45,861
все, и GC должен собрать все неиспользуемые
объекты. Это действительно важно

184
00:24:46,583 --> 00:24:52,852
для интерпретатора. Другая вещь, если я
помню правильно, Марк Шеннон работает над

185
00:24:52,892 --> 00:25:00,719
инкрементальным GC, это
то же самое, как это обрабатывается инкрементально, так что

186
00:25:01,16 --> 00:25:07,832
вы можете ожидать более быстрый GC, но на данный момент
я не могу вспомнить прогресс

187
00:25:07,852 --> 00:25:13,803
инкрементального GC, поэтому я думаю, вы можете открыть оригинальный
issue, чтобы узнать больше. Потому что я не эксперт в

188
00:25:14,004 --> 00:25:23,238
этой области. Я думаю, что у нас был очень интересный баг
в 3.13, когда в последнем релиз-кандидате, когда новый

189
00:25:23,278 --> 00:25:30,508
GC был объединен, и это замедлило многие случаи на
несколько заметных процентов, скажем так.

190
00:25:31,149 --> 00:25:40,683
И люди очень быстро создали новый релиз-кандидат
и откатили изменения GC. И теперь мы

191
00:25:40,724 --> 00:25:49,481
получим новый GC в 3.14. Я так думаю, по крайней мере, я надеюсь,
потому что это действительно большая работа, и не многие

192
00:25:49,521 --> 00:25:58,372
люди знают, насколько сложно на самом деле
реализовать сборщик мусора для языка, такого как

193
00:25:58,472 --> 00:26:07,643
Python, с учетом всех гарантий обратной совместимости.
Так что ты сказал, что ты очень

194
00:26:07,723 --> 00:26:15,683
заинтересован в поддержке ARM и free-threading.
Есть ли у тебя какая-то конкретная работа или конкретные проблемы,

195
00:26:15,723 --> 00:26:24,856
которые ты имеешь в виду, которые касаются обеих этих
тем? Да, одна вещь, о которой я не говорил, когда

196
00:26:24,916 --> 00:26:32,427
объяснял free-threading, как ты знаешь,
Python 3.13 — это просто своего рода чистое доказательство концепции

197
00:26:32,707 --> 00:26:39,136
версии free-threading. И я знаю, что люди
на самом деле разочарованы проблемами производительности

198
00:26:39,217 --> 00:26:48,953
в однопоточном режиме в сборке free-threading, она очень медленная.
Потому что когда free-threading был введен, если я правильно

199
00:26:48,973 --> 00:26:57,37
помню, он был основан на Python 3.9, и у него не было
специализированного интерпретатора, который был написан

200
00:26:57,43 --> 00:27:07,997
Марком Шенноном. Он очень великий человек. Поэтому, когда мы
перенесли Python free-threading, мы не перенесли

201
00:27:08,858 --> 00:27:16,809
специализатор в Python 3.13. Так что это основная
причина, по которой однопоточная производительность

202
00:27:16,909 --> 00:27:27,52
free-threading низкая. Но в 3.14,
Мэтт Пейдж, Кен Джин, Сэм Гросс, и я, и Томас

203
00:27:27,56 --> 00:27:36,213
Вутерс, и многие другие люди присоединились. И мы
смогли перенести большинство случаев специализатора

204
00:27:36,233 --> 00:27:45,105
в потокобезопасный режим с использованием механизма per-thread.
Так что мы фактически запустили бенчмарк несколько недель назад

205
00:27:45,726 --> 00:27:57,047
между сборкой с GIL и free-threading. И теперь
она имеет 90% производительности сборки с GIL, так что это намного

206
00:27:57,107 --> 00:28:05,295
быстрее. Так что если вы используете free-threading в
Python 3.14, вы не будете разочарованы однопоточной

207
00:28:05,335 --> 00:28:11,22
производительностью. И еще более крутые вещи,
например, Кен Джин также представил tail call dispatch.

208
00:28:11,26 --> 00:28:23,068
Он может быть использован, если ваш Python собран
с помощью clang 19. И мы заметили, что

209
00:28:23,128 --> 00:28:32,872
сборка free-threading Python с Clang 19 и
tail call dispatch быстрее, чем сборка 3.13 с JIT. Так что

210
00:28:33,973 --> 00:28:41,044
вы можете наслаждаться всем этим. Но если вы используете
технические спецификации с стандартной сборкой, она будет быстрее.

211
00:28:41,064 --> 00:28:48,095
Я не уверен, как это объяснить, но
в 3.14 произойдет много магических вещей.

212
00:28:48,175 --> 00:28:56,488
Так что вы можете наслаждаться этим. Это мое простое
объяснение. Было много попыток сделать

213
00:28:56,975 --> 00:29:05,55
логику диспетчеризации байткода Python быстрее.
Первая техника, которую мы используем, — это "computed goto".

214
00:29:05,57 --> 00:29:17,653
И я думаю, что это была лучшая попытка на протяжении многих
лет. Но начиная с Clang 19, вы можете дать подсказку компилятору,

215
00:29:18,053 --> 00:29:28,044
чтобы он использовал tail call dispatch. Это тот же термин, что если вы запустите
алгоритм, между рекурсивным вызовом и

216
00:29:28,164 --> 00:29:38,575
tail call, последний будет быстрее, потому что он
не требует дополнительного места в стеке и дополнительных накладных расходов, и

217
00:29:38,735 --> 00:29:51,305
он также предоставляет своего рода оптимизацию регистров,
но его нужно модифицировать, чтобы он был более знаком с

218
00:29:51,405 --> 00:30:03,578
логикой tail call dispatch. В данный момент Кен Джин фактически
переписывает генератор кода, чтобы он был более знаком с

219
00:30:03,598 --> 00:30:13,376
оптимизацией tail call. Затем, если этот tail call
dispatch собран с помощью Clang 19, его производительность

220
00:30:13,496 --> 00:30:23,814
увеличивается почти на 10%. Так что это очень
удивительный проект. Я думаю, вы можете ожидать его в ближайшее время.

221
00:30:23,834 --> 00:30:31,285
Даже если вы не знаете технических деталей о том,
как работает tail call dispatch,

222
00:30:31,305 --> 00:30:39,538
вы можете просто использовать `uv`. И если вы
используете `uv` для установки Python 3.14

223
00:30:40,419 --> 00:30:49,232
Они уже собирают Python 3.14 с помощью
Clang 19. Так что вы можете просто использовать его.

224
00:30:49,252 --> 00:30:58,623
Это потрясающая функция, я думаю. Да, это еще одна
оптимизация, даже лучше, чем computed GOTOs для

225
00:30:58,683 --> 00:31:05,471
диспетчеризации байткода, и вы должны обязательно попробовать.
Я думаю, что она будет отключена по умолчанию для

226
00:31:05,511 --> 00:31:16,638
этого релиза. Я ошибаюсь? Да, ты прав. Это мое
личное мнение об этом решении, но это

227
00:31:16,699 --> 00:31:26,118
все еще на рассмотрении, хорошо?
Решение не окончательное. Я верю, что

228
00:31:26,138 --> 00:31:35,142
техническая диспетчеризация не вызовет больших проблем, но
мы не можем гарантировать безопасность

229
00:31:35,362 --> 00:31:42,194
на данный момент, потому что нам нужно знать, что реальные
люди используют это. Могут быть неожиданные баги.

230
00:31:42,214 --> 00:31:50,965
Затем нам нужно будет их исправить. Так что, если мы не сможем включить это по умолчанию
в Python 3.14. Когда мы получим отзывы, это может

231
00:31:50,985 --> 00:32:01,459
занять один или два года. Это может быть поздно. Так что люди будут
страдать, если будут баги. Поэтому правильный путь — это

232
00:32:01,479 --> 00:32:09,089
оставить это отключенным, чтобы гарантировать более стабильное поведение. Но
как я сказал, `uv` уже предоставляет

233
00:32:09,129 --> 00:32:15,898
tail call dispatch для Python 3.14. Вы можете
просто протестировать его и использовать. И если нет проблем, он

234
00:32:15,918 --> 00:32:23,55
может быть включен по умолчанию в будущем.
Хорошо, я думаю, что ты затронул еще одну очень

235
00:32:23,59 --> 00:32:31,742
интересную тему, которую я не указал в своих
предыдущих заметках для тебя. Но Relocatable Build —

236
00:32:32,043 --> 00:32:37,571
это тоже очень интересный большой проект, над которым
сейчас работают многие люди. Можешь ли ты объяснить,

237
00:32:37,651 --> 00:32:47,076
как это связано с Python и что происходит
в этой области? Да. Если ты используешь `uv`,

238
00:32:47,096 --> 00:32:56,691
особенно часть с дистрибутивом CPython,
ты фактически используешь другой бинарный файл Python, который

239
00:32:56,751 --> 00:33:07,569
основан на standalone сборке Python, это как
использование статической сборки, которая ориентирована на

240
00:33:07,609 --> 00:33:14,721
совместимость с несколькими платформами с одной
сборкой. Так что это очень удивительный проект, потому что

241
00:33:16,203 --> 00:33:29,95
некоторые люди, которые работают в закрытом интернете или без
интернета, могут использовать это как новый способ

242
00:33:30,25 --> 00:33:38,85
развертывания нескольких дистрибутивов Python. Это очень
удивительный проект. Если ты используешь `uv python install`, ты

243
00:33:39,492 --> 00:33:52,758
используешь концепцию relocatable build. Люди из
Astral сейчас тесно сотрудничают с разработчиками CPython, чтобы сделать

244
00:33:53,099 --> 00:34:01,13
relocatable builds проще, быстрее и менее подверженными ошибкам,
потому что есть некоторые баги. Я думаю, что многие

245
00:34:01,35 --> 00:34:09,401
проблемы с relocatable builds связаны с
нашей оптимизацией BOLT. Я видел, может быть, пять тикетов

246
00:34:09,441 --> 00:34:17,215
об этом, что-то вроде того. Да. Нам нужно
разделить эти две темы с этим вопросом,

247
00:34:17,235 --> 00:34:24,765
потому что они собирают Python
используя статическую сборку, без динамической линковки.

248
00:34:24,865 --> 00:34:34,737
Можно ожидать, что итоговый бинарный файл будет огромным,
намного больше, чем обычный бинарный файл Python.

249
00:34:34,797 --> 00:34:42,754
Итак, BOLT — это инструмент оптимизации, разработанный Meta*
(в России признана экстремистской и запрещена)

250
00:34:43,417 --> 00:34:50,526
и есть несколько техник оптимизации компилятора,
базовые вещи могут быть, если вы передадите

251
00:34:50,706 --> 00:35:01,062
опцию `-01`, `-02`, `-03` в GCC, компилятор
оптимизирует ваш код в соответствии с их политикой. И это одна

252
00:35:01,102 --> 00:35:13,188
часть процесса оптимизации. Другая часть —
это PGO, который фактически собирает

253
00:35:13,208 --> 00:35:22,841
профилирование во время выполнения и затем пересобирает
бинарный файл с помощью компилятора. Это мы называем обычным процессом

254
00:35:22,901 --> 00:35:32,914
оптимизации компилятора. Но другая вещь — это то, что мы называем
пост-бинарной оптимизацией. Поскольку бинарный файл огромный,

255
00:35:34,557 --> 00:35:42,195
там много ошибок и промахов кэша.
И одна из техник, которые они используют,

256
00:35:42,296 --> 00:35:50,19
похожа на PGO. Они фактически собирают
профили двумя способами. Один из них —

257
00:35:50,23 --> 00:35:55,499
инструментация, а другой способ — это
живое профилирование, например, в рабочем трафике.

258
00:35:56,02 --> 00:36:06,659
Затем они перераспределяют структуру бинарного файла,
чтобы он был более оптимизирован для кэша,

259
00:36:06,679 --> 00:36:14,061
дополнительного кэша. Например, если какая-то область кода
используется очень часто, она группируется. А если

260
00:36:14,181 --> 00:36:24,316
это область, которая выполняется реже, она отделяется от
основной области. И тогда можно ожидать, что промахи кэша

261
00:36:24,817 --> 00:36:31,727
уменьшатся. Затем они также устраняют ненужные
области бинарного файла. Итоговый размер бинарного файла может быть уменьшен. Поэтому

262
00:36:31,787 --> 00:36:37,516
они работают над BOLT, потому что они являются
основным заказчиком, использующим BOLT. Мы добавили

263
00:36:37,977 --> 00:36:45,374
поддержку BOLT в, возможно, 3.13 для CPython. Я не помню
точно, поэтому они фактически

264
00:36:45,434 --> 00:36:54,747
работают над этим. Я думаю, что BOLT был введен в
Python 3.12. Да, 3.12, точно. Что-то вроде того. И

265
00:36:54,847 --> 00:37:04,018
я думаю, что ты был тем, кто внес вклад в это. Так что
это еще один большой проект от тебя. Давай отдадим

266
00:37:04,038 --> 00:37:16,372
должное. Но я должен сказать, что BOLT был фактически
первой попыткой от людей, работающих над Pyston.

267
00:37:16,392 --> 00:37:25,31
Люди, которые работали в Dropbox, а затем разработали
версию Python под названием Pyston в Dropbox.

268
00:37:25,571 --> 00:37:34,423
После того, как они покинули Dropbox, они организовали
проект Faster CPython.

269
00:37:35,084 --> 00:37:41,593
В Pyston одной из оптимизаций,
которую они использовали, был BOLT. Мы фактически

270
00:37:41,653 --> 00:37:52,251
переняли их технику. Я хочу сказать, что основная
работа была проделана этими людьми, а моя работа заключалась в

271
00:37:52,451 --> 00:37:58,346
поддержке внедрения BOLT, например,
в определении частей, где мы можем его использовать. Так что я благодарю тебя за

272
00:37:58,447 --> 00:38:07,973
признание, но мне нужно уточнить это. И также отдать должное другим
людям. Да. Хорошо, у меня есть

273
00:38:08,514 --> 00:38:16,865
последний технический вопрос, но он также очень глубокий,
так что давайте подготовим нашу аудиторию к нему. Я думаю, что

274
00:38:17,546 --> 00:38:26,698
в Python 3.14 произойдут большие изменения в нашем JIT
пайплайне, потому что сейчас нам требуется LLVM как зависимость

275
00:38:26,738 --> 00:38:34,348
во время сборки. И предлагается устранить эту
зависимость во время сборки. Есть ли у тебя

276
00:38:34,388 --> 00:38:42,818
какая-то информация об этом? Например, что произойдет
и как это будет работать? Да, есть попытка

277
00:38:42,878 --> 00:38:50,327
убрать зависимость от LLVM во время сборки
CPython, но также есть PEP по этому поводу,

278
00:38:50,367 --> 00:38:58,237
и Steering Council сейчас рассматривает этот PEP.
Так что на данный момент я не могу ничего сказать о PEP.

279
00:38:58,258 --> 00:39:05,868
Мне было бы сложно на данный момент.
Хорошо, да, я полностью понимаю.

280
00:39:05,888 --> 00:39:14,119
Я думаю, что мы должны добавить ссылку на этот PEP в
описание, чтобы люди могли прочитать его и выразить свое

281
00:39:14,159 --> 00:39:22,869
мнение в обсуждении, в discourse,
если у них есть такие мнения. Это мое личное

282
00:39:22,949 --> 00:39:31,381
мнение, но если мы успешно завершим этот проект,
эти задачи сборки больше не понадобятся.

283
00:39:31,401 --> 00:39:40,293
Так что да, это будет очень важный PEP
для проекта. Но окончательное решение будет

284
00:39:40,313 --> 00:39:46,922
принято Steering Council. Так что я не могу ничего сказать.
Хорошо. Хорошо. У меня нет мнения

285
00:39:47,102 --> 00:39:54,767
по этому поводу, потому что это выходит за пределы моей экспертной области.
Последний вопрос о твоей другой

286
00:39:54,787 --> 00:40:03,401
деятельности. Ты сказал, что также организуешь спринты в
своем родном городе и приглашаешь людей присоединиться и

287
00:40:03,481 --> 00:40:09,771
участвовать. Можешь ли ты рассказать немного больше
о том, что это за спринты, какие результаты

288
00:40:09,931 --> 00:40:17,062
и как ты их организуешь? Что должны делать люди
там? Да, в каждом регионе может быть много

289
00:40:17,202 --> 00:40:25,794
локальных спринтов для разработки CPython, но в Корее,
Японии или Таиланде, возможно, в России, я знаю, что

290
00:40:25,954 --> 00:40:34,406
нет спринтов, организованных основными
разработчиками. Так что для некоторых людей может быть

291
00:40:34,866 --> 00:40:43,724
сложно участвовать в US PyCon из-за
финансовых проблем, расстояния,

292
00:40:43,844 --> 00:40:56,221
или занятости. Поэтому я стараюсь
организовать спринт, где можно работать над CPython

293
00:40:56,261 --> 00:41:04,85
в течение одного дня в Корее. Я стараюсь предоставить помощь и
руководство о том, как можно внести вклад в

294
00:41:04,89 --> 00:41:12,198
CPython, как запустить CI, как выполнять новые задачи,
и как писать новый код, и как получить

295
00:41:12,298 --> 00:41:24,201
рецензию от команды CPython. Это одна из моих
попыток организовать спринт в моем регионе.

296
00:41:24,221 --> 00:41:31,634
Потому что я думаю, что такие активности —
это один из способов, с помощью которых люди могут улучшить

297
00:41:31,694 --> 00:41:38,126
рейтинг сообщества в CPython. Люди
представляют свою позицию и свои потребности, и

298
00:41:38,266 --> 00:41:44,296
если они принимают участие в решении проблем, они могут
стать более знакомыми с процессом. Поэтому я верю, что такие активности могут

299
00:41:44,357 --> 00:41:54,063
увеличить взаимодействие между основной командой Python
и другими людьми.

300
00:41:54,103 --> 00:42:02,082
Спасибо. Это действительно замечательная активность,
и я надеюсь однажды

301
00:42:02,162 --> 00:42:07,871
поучаствовать в таких мероприятиях или даже организовать
их, потому что я полностью согласен. Дать людям понять,

302
00:42:07,911 --> 00:42:18,006
что вносить вклад в CPython легко и весело, — это большая
цель, потому что многие считают, что это тяжелая

303
00:42:18,567 --> 00:42:28,564
работа, которая не приносит удовольствия, но это тяжелая работа, которая приносит удовольствие.
И я думаю, что многие должны знать, что вы можете

304
00:42:28,604 --> 00:42:35,617
это делать, и вы должны это делать. И я стараюсь поощрять людей
с помощью своих видео вносить вклад в CPython,

305
00:42:35,697 --> 00:42:44,83
сообщать о проблемах с неожиданным поведением
и тому подобное. Так что в этом году,

306
00:42:44,87 --> 00:42:51,478
в моем расписании — Южная Корея,
я стараюсь организовать это в августе. Так что если вы посетите

307
00:42:51,538 --> 00:43:02,43
Корею, возможно, PyKR пройдет 15 августа. Так что вы
можете присоединиться к спринту, если посетите Корею. Я также планирую

308
00:43:02,49 --> 00:43:11,947
посетить Тайвань в этом году. Так что если у вас есть планы
посетить Тайвань, возможно, вы также сможете посетить спринт.

309
00:43:12,067 --> 00:43:20,362
И если будут другие возможности, я постараюсь их поддержать.
И я думаю, что вы тоже можете организовать спринт. Так что если вам нужны

310
00:43:20,602 --> 00:43:31,702
ресурсы для локального спринта, я с радостью
предоставлю то, что использую для локальных спринтов в Токио или

311
00:43:31,722 --> 00:43:41,471
Сеуле или любом другом регионе. Отлично. Спасибо. И еще раз,
большое уважение за вашу работу над CPython и

312
00:43:41,592 --> 00:43:48,446
вашу работу в Steering Council. Мы действительно должны
ценить таких людей, как вы, и отдавать должное за всю

313
00:43:48,486 --> 00:43:55,26
тяжелую работу, которую они делают для всего мира.
Еще раз спасибо, и спасибо за то, что пришли и дали это

314
00:43:55,341 --> 00:44:02,615
интервью. Я надеюсь, что людям понравится. И если вы
оставите свои контакты, ваш GitHub, например,

315
00:44:02,675 --> 00:44:11,604
и у людей будут вопросы о free-threading,
могут ли они упомянуть вас? Да, я предоставлю

316
00:44:11,644 --> 00:44:21,816
мой GitHub username. Мой handle — это очень
странное имя. Это @corona10. Оно не связано с той

317
00:44:21,836 --> 00:44:32,828
Короной. Да, но я использую его с 2019 года, так что
мне все равно. Так что мой handle на GitHub — @corona10,

318
00:44:32,948 --> 00:44:45,708
а мой Twitter — @dongheena92, 92 — это год моего рождения, так что
вы можете связаться со мной, если хотите. И моя почта —

319
00:44:45,969 --> 00:44:51,796
donghee.na@python.org. Я добавлю все в
описание, чтобы люди могли с вами связаться.

320
00:44:51,836 --> 00:44:57,163
Вы можете просто написать мне на почту, и я с радостью
отвечу, если у вас есть интерес к

321
00:44:57,303 --> 00:45:05,691
внесению вклада в CPython. Я знаю, что хочу сказать Никите,
ты тоже отличный основной

322
00:45:05,712 --> 00:45:12,579
разработчик, который взаимодействует с внешними
контрибьюторами. Так что я хочу также сказать спасибо за все твои

323
00:45:12,98 --> 00:45:19,568
активности и работу над CPython. Да. Я очень уважаю
твои активности, включая триажирование

324
00:45:19,688 --> 00:45:26,496
проблем, исправление всего. Да. Я очень уважаю
твои активности тоже. Да, спасибо. Спасибо.

325
00:45:26,656 --> 00:45:33,163
Спасибо. Пока-пока. И это все на данный момент. Я надеюсь, что это было
интересно, потому что во время интервью это было

326
00:45:33,243 --> 00:45:39,52
действительно очень интересно лично для меня. Я узнал много нового,
я поговорил с удивительным умным человеком, и это

327
00:45:39,54 --> 00:45:47,065
всегда очень приятно. И я надеюсь, что теперь вы также знаете,
что вы можете управлять таким языком программирования, как Python.

328
00:45:47,426 --> 00:45:53,357
Это реалистичная цель для инженеров, которые
интересуются этим. И я надеюсь, что, возможно, хотя бы один

329
00:45:53,377 --> 00:45:58,867
из вас я смог мотивировать развивать свои навыки в этом
направлении. Я буду рад помочь любым способом, если кто-то

330
00:45:58,887 --> 00:46:05,398
захочет. И у меня есть три замечательных ссылки, как обычно.
Первая ссылка — это мой GitHub. Вы можете поддержать мою работу

331
00:46:05,418 --> 00:46:11,688
там, поставив звезды или сделав форки. Вы можете
поддержать мою работу на Boosty, если хотите поддержать

332
00:46:11,868 --> 00:46:18,679
рублями, это всегда приятно. Я не предлагаю уникального
контента, я считаю, что весь контент должен быть бесплатным и

333
00:46:19,02 --> 00:46:24,348
открытым для всех, так что это просто дополнительная
мотивация для меня. И, конечно, мой Telegram

334
00:46:24,368 --> 00:46:32,344
канал. Мой Telegram канал — это место, где много
технической информации о Python. Так что если вам

335
00:46:32,364 --> 00:46:38,116
нравится такой контент, присоединяйтесь. Например,
недавно я написал серию из двух постов о том, как работает

336
00:46:38,197 --> 00:46:44,569
GIL в Python. И, конечно, я показал код на
C, который физически показывает внутренности Python

337
00:46:44,589 --> 00:46:50,798
и операционной системы, чтобы показать, как происходит
переключение GIL. Так что если вам интересен

338
00:46:50,818 --> 00:46:56,627
текстовый контент о внутренностях Python, присоединяйтесь.
Ну, а если вы хотите увидеть кого-то конкретного в качестве

339
00:46:56,647 --> 00:47:01,514
гостя, вы можете написать в комментариях, кого бы вы хотели
увидеть, и я постараюсь пригласить этого человека и поговорить с

340
00:47:01,534 --> 00:47:05,5
ним о том, чем он занимается. Это все от меня, большое спасибо,
пока.
